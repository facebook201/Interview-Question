首先看一个知乎问答 大公司里面怎么开发和部署代码？回答者 张云龙

主要内容如下：

* 304（服务器没有更新） 是协商缓存 和服务器还要通信一次

* 强制浏览器使用本地缓存（cache-control/expires）不要和服务器通信。那么问题来了 不和服务器通信 怎么更新？**让url的修改与文件内容关联，也就是说 只要文件内容变化 才会导致相应内容url变更，从而实现文件级别的精确缓存控制**

  ![border](https://pic1.zhimg.com/4681f7131e777dc885bf66000580ca40_b.jpg)

  关于采用内容摘要作为缓存更新依据。我们真正要更新的是新的内容 而不是版本号。所以利用数据摘要算法对文件求摘要信息。 就是hash。**每个文件内容生成哈希值，哈希值与文件内容一一对应，就可以精确到单个文件缓存控制** 

  补充：

  ​	MD5算法。是不可逆的。原因是一种散列函数，使用的hash算法。MD5算法属于摘要算法 用于检查报文是否被篡改，而不是加密的。 AES用于适合明文传输的报文。

  ​

* 提升性能之 静态资源和动态网页分集群部署。 静态资源部署到CDN节点上。网页中引用的资源也会变成对应的部署路径

  CDN (内容分发网络 CDN系统能够实时地根据[网络流量](https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F)和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决 Internet[网络拥挤](https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E6%8B%A5%E6%8C%A4)的状况，提高用户访问网站的响应速度。)

  ​

* 非覆盖式发布

  用待发布的资源覆盖已发布的资源，无论是先上线页面，还是先上线静态资源都会在部署过程中发生页面错乱的问题。 所有用非覆盖式发布、用文件的哈希值来对资源文件进行重命名，把哈希字符串放到资源文件发布路径中。 这样 内容有修改的资源就变成了一个新的文件发布到显示 不会覆盖已有的资源文件。

  ​



大公司的静态资源优化方案 基本实现这几个

1、配置超长时间的本地缓存                 —— 节省带宽，提高性能

2、采用内容摘要作为缓存更新依据      —— 精确的缓存控制

3、静态资源CDN部署                           —— 优化网络请求

4、更资源发布路径实现非覆盖式发布  —— 平滑升级



![border](https://segmentfault.com/img/bVuuo2)

#### 浏览器缓存机制

* 1 强缓存：不会向服务器发送请求，直接从缓存中读取资源。直接返回200。并且size显示from disk cache或from memory cache；

* 2 协商缓存 想服务器发送请求。 服务器会根据这个请求的参数来判断是否命中协商缓存。  返回304 从缓存中读取资源；

  区别在于 强缓存不会发出请求

  ​

* 强缓存

  * Expries: respone header 里的过期时间 浏览器再次加载资源 如果在这个过期时间内 则命中强缓存

  * cache-control: 当值设为max-age=300时，表示这个请求正确的返回时间（浏览器也会记录下来），5分钟内这个资源再次加载 就会命中强缓存

    两者的区别是 Expires 是 http1.0的产物，Cache-Control是1.1的。如果两者同时存在 Cache-Control的优先级高于Expires。Expires是一种兼容写法。

    ​

* 协商缓存

  * ETag和If-None-Match： Etag是上一次加载资源时服务器返回的response header，是该资源的一种唯一标识。只要资源有变化，Etag就会重写生成。 浏览器下一次请求加载资源向服务器发送请求时 会将上一次返回的Etag放到request header里的if-None-Match里面。 服务器接受到if-None-Match值之后。会拿来跟资源文件的Etag做比较 如果相同就表示文件没有改变 命中协商缓存

  * Last-Modified 跟 Etag作用差不多 他们的区别在于：

    * Etag精度优于Last-Modified。 Last-Modified单位是秒 如果某个文件在一秒内改变了很多次 那么他们的last-Modified并没有体现出来 ，但是Etag每次都会改变确保了精度。如果是负载均衡的服务器 各个生成的Last-Modified也可能不一样

    * Etag性能逊于(没有last-Modified)Last-Modified好 毕竟Last-Modified 只需要记录时间 而Etag需要服务器通过算法计算一个hash值

    * 服务器有限考虑Etag

    * ETag的值服务端是对文件的索引节，大小和最后修改时间进行Hash后得到的

      ​

* 304缓存，有了Last-Modified，为什么还要用ETag？有了Etag，为什么还要用Last-Modified？Etag一般怎么生成？
  **有了Last-Modified，为什么还要用ETag？**
  （1）因为如果在一秒钟之内对一个文件进行两次更改，Last-Modified就会不正确。
  （2）某些服务器不能精确的得到文件的最后修改时间。
  （3）一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET。

  **有了Etag，为什么还要用Last-Modified？**
  因为有些时候 ETag 可以弥补 Last-Modified 判断的缺陷，但是也有时候 Last-Modified 可以弥补 ETag 判断的缺陷，比如一些图片等静态文件的修改，如果每次扫描内容生成 ETag 来比较，显然要比直接比较修改时间慢很多。所有说这两种判断是相辅相成的。

  ETag的值服务端是对文件的索引节，大小和最后修改时间进行Hash后得到的。



* 缓存的过程

  浏览器第一次加载资源，服务器返回200，浏览器将资源文件从服务器上请求下载下来，并把response header及该请求的返回时间一并缓存；

  下一次加载资源时，先比较当前时间和上一次返回200时的时间差，如果没有超过cache-control设置的max-age，则没有过期，命中强缓存，不发请求直接从本地缓存读取该文件（如果浏览器不支持HTTP1.1，则用expires判断是否过期）；如果时间过期，则向服务器发送header带有If-None-Match和If-Modified-Since 的请求；

  服务器收到请求后，优先根据Etag的值判断被请求的文件有没有做修改，Etag值一致则没有修改，命中协商缓存，返回304；如果不一致则有改动，直接返回新的资源文件带上新的Etag值并返回 200；

  如果服务器收到的请求没有Etag值，则将If-Modified-Since和被请求文件的最后修改时间做比对，一致则命中协商缓存，返回304；不一致则返回新的last-modified和文件并返回 200；

  用户行为对浏览器缓存的控制

  地址栏访问，链接跳转是正常用户行为，将会触发浏览器缓存机制；

  F5刷新，浏览器会设置max-age=0，跳过强缓存判断，会进行协商缓存判断；

  地址栏访问，链接跳转是正常用户行为，将会触发浏览器缓存机制；

  F5刷新，浏览器会设置max-age=0，跳过强缓存判断，会进行协商缓存判断；

  ctrl+F5刷新，跳过强缓存和协商缓存，直接从服务器拉取资源。

  ​



#### HTTP状态

* 200 成功
* 302 / 301 重定向 请求资源在其他地方。 浏览器应该自动访问新的URL
* 304 协商缓存 表示服务器 原来的文件还可以继续使用 服务器没有更新
* 403 资源不可以 一般是权限问题
* 404 无法找到资源
* 405 请求方法对指定资源不适应
* 500 服务器问题

























